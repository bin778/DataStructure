자료 구조 : List / stack / Queue ==> 선형구조
           tree / heap ==> 비선형 구조
           sort(정렬)
           그래프

// 배열 리스트가 empty인 상태에서 항목을 읽으려 할 때 프로그램을 정지시킨다.
import java.util.NoSuchElementException;

배열 리스트 ex)
public class ArrList<E> {
    private E a[];
    private int size; // 리스트의 항목 수

public ArrList() { // 생성자
    a = (E[])new Object[1]; // 1개의 원소를 가지는 배열
    size = 0; // 항목을 0으로 초기화
  }
}

제네릭(Generic) : 객체의 타입을 저장하는 것
노드(Node) : 데이터의 최소 저장 단위
재귀(Recursion) : 자기 자신을 참조하는 것

<E>, <T>
<Object>

연결(링크) 리스트 ex)
public class ListNode {
    private int data; // 실제 노드
    private ListNode next; // 리스트 노드
    public ListNode(int data) {  }
}

List -> 1. 배열 리스트 -> 오버플로우. 즉, 값이 초과될 가능성이 있음
--> 그래서 배열을 만들때는 배열의 사이즈를 2배 정도 크게 만든다.
        2. 연결 리스트 : 2-1 -> 자기 참조 리스트
                        2-2 -> 외부 참조 리스트
        3. 원형 리스트
        
참조(Reference)변수 : 값이 저장되는 변수. 즉, 참조변수는 주소값이 저장되어 있다.

ArrList ==> 1. 탐색, 2. 삽입, 3. 삭제

  // 리스트의 삭제
  public E peek(int k) { // k번째 저장된 항목을 검색, a[k]
    if(size == 0) { // 항목(X)
      throw new NoSuchElementException; // 프로그램 stop
    }
  return a[k];
  }
  
  // 리스트의 삽입
  public void insertLast(E newItem) {
    if(size == a.length)
      resize(2*a.length); // a의 사이즈를 2배로 늘린다.
    a[size++] = newItem;
  }
  
  public void insertLast(E newItem) {
    if(size == a.length) {
      resize(2*a.length);
      for(int i = size -1; i >= k; i--) {
        a[i + 1] = a[i];
      }
    a[k] = newItem;
    a[size++];
    }
  }
  
자바 메인 메모리 == 1. 프로그램이랑 static 데이터가 저장되는 영역
                   2. heap 영역 : 객체 ---------------------------- 가비지
                   3. stack 영역 : 변수 / 메소드
                     
  public void resize(int newSize) {
    Object[] o = new Object[newSize];
    for (int i = 0; i < size; i++)
      o[i] = a[i];
    a = (E[])o;
  }

삭제 연산
  public E delete(int k) {
    if(isEmpty()) throw new NoSuchElementException();

    E item = a[k];
    for(int i = k; i < size; i++)
      a[i] = a[i + 1];
    size--;
    
    return item;
  }
