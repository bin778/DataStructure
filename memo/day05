연결 / 배열

Q1)
선형리스트 = 배열리스트
리스트 L = { Kim, Lee, Park, Song };

선형리스트 (L)
Kim   Lee   Park  Song
L0    L1    L2    L3

연결 리스트
[Kim][-]-[Lee][-]-[Park][-]-[Song][-]-NULL

String name = NULL

String name1 = "길동";
String name2 = "길동";
-------------------------------------
String name1 = "길동";
name2 = "순신";
-------------------------------------
String name3 = new String("길동");
-------------------------------------

stack 영역    heap 영역   String 객체
name1         길동

Kim -> Lee -> Park -> Song -> NULL
A1) --> LinkedList1 

컴포지션 : 클래스에서 다른 클래스의 오브젝트의 객체를 생성하는 것

Q2) 자료를 입력하시오(Scanner사용)
  ==> 자료 입력 마침 문자는 : *
    21 43 50 74 *
  ==> 리스트 출력
    21 -> 43 -> 50 -> 74 -> null;
  
Q3) LinkedList1을 for문의 형식으로 변경 (kim, lee, park, song) ==> 배열화 하여 작업

중첩 클래스(이너 클래스) ==> 클래스 안에 클래스 선언
  public class A {
    class Node {
      멤버 필드, 메소드, 생성자 --> 은닉화, 캡슐화
    }  
  }
익명 내부 클래스 : Listener(GUI) new Test(new Listener() {
  
});
이너 클래스
A.class
A$Node.class
A$1Node.class

Q4) 출력 결과
1) 리스트 출력
  15 -> 35 -> 67 -> 87 -> null
2) 원소 28 삽입
  15 -> 28 -> 35 -> 67 -> 87 -> null
3) 원소 45 삽입
  15 -> 28 -> 35 -> 45 -> 67 -> 87 -> null  

알고리즘
intNode.data = x; // 노드의 데이터
inaNode.link = L; // L 노드 앞에 inaNode 연결
L = inaNode; // L --> inaNode

Node search(Node L, int x) { // 삽입할 위치 검색(단, 알고리즘이기 때문에 error 발생할 수 있음!!)
  Node tmp = L;
  Node position = L; // position은 삽입할 위치의 앞 노드
  while(tmp != null && x > (Integer)tmp.data) {
    position = tmp;
    tmp = tmp.link;
  }
  return position;
}

tmp = position.link; // pos 후행 노드를 tmp가 가리킴
position.link = inaNode; // pos뒤에 삽입할 노드 inaNode 연결
inaNode.data = x; // inaNode의 자료에 데이터 저장
inaNode/link = tmp; // inaNode 뒤에 tmp 연결

Node obj = new Node();
Node L = null;
L = obj.makeN();
L = obj.insert(L,28);
L = obj.insert(L,45);
L = obj.insert(L,7);

class Node {
  Object data;
  Node link;
  
  Node makeN() 
}

끊어진 노드를 다음 노드로 변경
Node tmp = L;
Node position = L;
while(tmp != null && x != (Integer)tmp.data) {
  position = tmp;
  tmp = tmp.link; // 다음 노드로 변경
}
return position;
} // position과 tmp 둘 다 같음
// 처음 노드 삭제하는 작업

tmp = position.link;
position.link = tmp.link;
// position과 tmp를 서로 분리
// 중간 노드 삭제하는 
